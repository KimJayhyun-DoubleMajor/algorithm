# 분할 정복 개념

## 개념
- 분할 단계
  - 원래의 문제를 소문제로 분할
- 정복 단계
  - 소문제의 해를 순환적으로 구함
- 합병 단계
  - 소문제의 해를 합하여 원래 문제에 대한 해를 구함

# 퀵 정렬
## 개념
- 기준이 되는 숫자(Pivot)을 정함
- 그 숫자를 기준으로 작은 데이터와 큰 데이터를 나눔
- 분리된 양쪽의 데이터에서 기준이 되는 숫자를 정함
- 그 숫자를 기준으로 작은 데이터와 큰 데이터를 나누는 작업을 반복

### 조건
- 기준이 되는 값보다 작은 값을 찾기 위한 인덱스와 큰 값을 찾기 위한 인덱스가 필요함
- 작은 값을 찾기 위한 인덱스는 왼쪽부터 진행
- 큰 값을 찾기 위한 인덱스는 오른쪽에서 진행

### 과정
- 작은 값을 찾기 위한 인덱스가 기준값보다 크거나 같을 경우 멈춤
- 큰 값을 찾기 위한 인덱스가 기준값보다 작거나 같은 경우 멈춤
- 그 상태에서 해당 인덱스에 위치한 데이터의 위치를 바꿈
- 위 작업을 반복하면 기준값을 기준으로 죄측에는 작거나 같은 값, 우측에는 크거나 같은 값이 위치
- 정렬된 데이터 집합에서 다시 퀵 정렬을 적용
  
### 동작 단계
1. Pivot 값을 정함
2. 피벗값을 중심으로 파티션을 나눔
3. 나눈 파티션을 재귀적으로 1, 2를 반복

### 정리 
- 평균 실행시간
  - $O(NlogN)$
- 최악 실행 시간
  - $O(n^2)$


### 특징
- 구현이 쉽고 자원이 적게 사용됨
- 범용적이여서 많이 사용됨

# 힙 정렬
## Heap
- 여러 개의 노드들 가운데 가장 큰 키 값을 가지는 노드나 가장 작은 값을 가지는 노드를 빠른 시간 내에 찾아내도록 만들어진 자료구조
- 완전 이진 트리 중 하나
- 각 노드는 유일한 키 값을 가짐
- 우선 순위를 가지는 큐라는 의미에서 Priority Queue라고도 함

### 종류
- max-heap
  - 그 노드의 모든 자식들보다 큰 키 값을 가짐
- min-heap
  - 그 노드의 모든 자식들보다 작은 키 값을 가짐

## 정렬 방법
- max-heap을 이용
  - 최상단 root가 가장 큰 값이 됨
- max-heap이 만들어지면 최상단 root를 배열에 append

# 분포에 의한 정렬과 외부 정렬
## 계수 정렬
### 개념
- 입력키가 어떤 범위에 있다는 것을 알고 있을 때 적용 가능
  - 1 부터 `k` 사이의 작은 정수 범위에 있음
- 입력 키들이 범위 `k`내의 각 값에 대하여 실제로 입력에 나타나는 횟수를 계산

### 시간 복잡도
- $O(n + k) = O(n)$ 
- 동일한 키의 순서가 바뀌지 않는 안정적 정렬

### 프로세스
1. 각 데이터가 몇 개가 있는지 카운트 배열에 저장
  - `0`은 1 번, `1`은 3 번, `2`는 2 번 ...
  - 1, 3, 2
2. 카운트 배열에서 각 값을 누적하여 재할당
  - 1, 4, 6
3. `temp` 배열에 값을 정렬

## 기수 정렬
- 전체 키를 여러 자리로 나누어 각 자리마다 계수 정렬과 같은 안정적인 알고리즘을 적용
- 각 자리에 $O(n)$ 시간이 걸리므로 d 자리수 배열은 $O(dn) = O(n)$ 시간 복잡도를 가짐
- 비 재자리 정렬이므로 메모리 여유가 필요함

### 프로세스
- 한 자리수를 기준으로 각 큐에 계수 정렬을 기준으로 데이터를 담음


## 버킷 정렬
### 개념
- 계수 정렬의 일반화