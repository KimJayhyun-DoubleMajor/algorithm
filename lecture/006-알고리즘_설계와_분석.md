# 알고리즘 설계 방법
## 개념
- 쉽게 설명할 수 없는 창조적인 영역
- 문제를 해결하는 사람의 창의적인 능력에 따라 다름
- 일반적인 알고리즘 기법
  - 그리디 알고리즘
  - 동적 프로그래밍
  - 분할 정복 알고리즘
  - 무작위 알고리즘
  - 근사 알고리즘

## 그리디 알고리즘
- 최적화 문제를 해결하는 알고리즘
- 가능한 해 중에서 가장 좋은 해를 찾는 문제
- 욕심쟁이 방법, 탐욕적 방법, 탐욕 알고리즘

### 활용
- 동전 거스름돈
- 최단 경로 찾기
- 최소 신장 트리
- 부분 배낭 문제
- 집합 커버 문제
- 작업 스케줄링

## 동적 프로그래밍(Dynamic programming)
- 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
- 작은 부분문제들을 모두 해결
- 그 해를 이용하여 보다 큰 부분문제를 해결
- 최종적으로 원래 주어진 입력의 문제를 해결

### 활용
- 모든 쌍 최단 경로
- 편집 거리 문제
- 배낭 문제
- 연속 행렬 곱셈
- 동전 거스름돈

## 분할 정복(Divide and Conquer) 알고리즘
- 주어진 문제의 입력을 분할하여 해결하는 알고리즘
- 분할된 입력에 대하여 동일한 알고리즘을 적용해 해를 계산
- 이들의 해를 취합하여 원래의 문제의 해를 구함

용어 | 설명 |
:---: | :---: |
분할 | 정렬하려는 배열을 $n/2$ 개의 부분 배열로 분할함
정복 | 부분 배열을 정렬
통합 | 정렬된 두 개의 배열을 합병하여 하나의 정렬된 배열로 만듬

### 활용
- 합병 정렬
- 퀵 정렬
- 이진 검색(Binary Search)


# 알고리즘 효율성 분석
## 개념
- 수행시간 또는 사용되는 메모리의 공간의 크기로 나타낼 수 있음
- 시간 복잡도, 공간 복잡도
  - "시간 복잡도"로 일반적인 알고리즘을 비교
- 알고리즘으로 프로그램을 구현하여 실행 시간을 측정
  - 여러 가지 변수가 있으므로 효율성을 객관적으로 평가하기 어려움
    - 어떤 컴퓨터에서 수행
    - 어떤 프로그래밍 언어
    - 얼마나 숙련된 프로그래머
- 따라서, 시간 복잡도는 알고리즘이 수행하는 기본적인 연산 횟수를 입력크기에 대한 함수로 표현 
  
### 예시
> 10 장의 숫자 카드 중 최대 숫자를 순차 탐색으로 찾자!
- 숫자의 비교 : 기본 연산
- 총 기본 횟수 : 9
- $(n - 1)$ 번의 비교

>  1에서 10까지 더하는 알고리즘
1. 1에서 10까지 숫자를 직접 하나씩 더한다.
    - 9 번 계산
2. 두 수의 합이 10이 되도록 숫자들을 그룹핑하여 그룹의 개수에 10을 곱하고 남은 숫자 5를 더한다.
    - 5 번 계산
3. 공식을 이용하여 계산한다.
    - 3 번 계산

## 알고리즘을 만드는 방법의 예
- 문제를 한 번에 해결하려 하지 말고 더 작은 크기의 문제로 분해함
- 문제가 충분히 작아질 때까지 분해

## 알고리즘 복잡도의 표현
### 최악 경우 분석
- 일반적인 시행하는 알고리즘의 복잡도
- 어떤 입력이 주어지더라도 얼마 이상을 넘지 않는다는 표현

### 평균 경우 분석
- 입력의 확률 분포를 가정하여 분석
- 대부분 균등 분포를 가정함

### 최선 경우 분석
- 최적 알고리즘을 고안하는데 참고 자료가 됨
- 거의 사용되지 않음

## 각각의 분석의 예
> 집에서 지하철까지 5분, 지하철에서 학교 근처역까지 20분, 강의실까지 10분

### 최선 경우 분석
- $5 + 20 + 10 = 35$

### 최악 경우 분석
- 전철을 6 분 기달린 경우
- $35 + 6 = 41$

### 평균 경우 분석
- 최악, 최선의 중간으로 가정하여 3 분
- $35 + 3 = 38$